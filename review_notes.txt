1. FindBookName result = FindBookName(driver); -> FindBookName findBookName = FindBookName(driver);

2. Date date2 = ticket.departueDate(); -> Date departueDate = ticket.departueDate();

3. public void EnterValues(String c1, String c2, String d1, String d2) {
     this.city1 = c1;
     this.city2 = c2;
     this.date1 = d1;
     this.date2 = d2;
   }

4. retStrDate.setDate("12/10/2017");

5. 
    public int getValue(int[] a) {
        int d = a[0];
        for (int i = 0; i < a.length; i++) {
            if (a[i] > d) {
                d = a[i];
            }
        }
        return d;
    }
    
    
    public int getMaxIntegerValueFromArray(int[] array) {
        int maxValue = array[0];
        for (int i = 0; i < array.length; i++) {
            if (array[i] > maxValue) {
                maxValue = array[i];
            }
        }
        return maxValue;
    }

6.

USE:
- follow code conversion;
- use comprehensive names;
- java convention:
     i and j for loops;
     ALL_CAPS for constants;
     ClassFromCapital;
     methodOrVariable;
     name of class - noun;
     method names should start with verb e.g. get, set, do;
     package name should follow standard company structure e.g. com.company.project.module

     
AVOID:
- magic naumbers;
- hungarian notation;
- abbreviations;
- x,y,z or another letters apart i/j;
- file2, sum1;
- unclear "flag", "result", "status" / "Instance", "Entity"
- God class/Magic Hammer (huge button pattern)
- data storage class (constants class)
- numbers like "Test2"
- "MyClass"


Absolute name
parser.parse(new FileReader("/home/vital/IdeaProjects/Perevozka/src/Tarif.json"));

Not obviously
if (km<=10&km>=1)


catch (Exception ex) {
   System.out.println("Error"); --- ??
}
  
public class Perevozka {
     Perevozka() {
         Scanner scan = new Scanner (System.in);
         int chislo = scan.nextInt();
         if (chislo>0)
            km = chislo;
         else
            System.out.println ("Vvedite pravilnoe chislo");
     }
     
     
static long MAX_VALUE -> A constant holding the maximum value a long can have, 2^63-1.     
         2`147`483`647    -> Integer.MAX_VALUE
9`223`372`036`854`775`807 -> Long.MAX_VALUE 

In Java 64-bit, long and double values were treated as two 32-bit values. That means, a 64-bit write operation is basically performed as two separate 32-bit operations.
https://dzone.com/articles/longdouble-are-not-atomic-in-java
    
long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;
    
    
long result;
if (km<=10&km>=1)
    result = (Long) jsonObject.get("1-10");
    

for (Object koefItem : jsonArray) { Object -> JSONObject
     JSONObject item = (JSONObject) koefItem;


public void setKoef() { --> name, magic button, every time reading file
        try {
            File fXmlFile = new File(filePath);
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(fXmlFile);
            doc.getDocumentElement().normalize();
            NodeList nList = doc.getElementsByTagName("group");
            for (int temp = 0; temp < nList.getLength(); temp++) {
                Node nNode = nList.item(temp);
                Element eElement = (Element) nNode;
                double start = Double.parseDouble(eElement.getElementsByTagName("start").item(0).getTextContent());
                double end = Double.parseDouble(eElement.getElementsByTagName("end").item(0).getTextContent());
                double koef = Double.parseDouble(eElement.getElementsByTagName("koef").item(0).getTextContent());
                if (this.weight >= start & this.weight < end) {
                    this.koef = koef;
                }
            }
            if (this.koef == 0) {
                System.out.println("max Weight can be 5000kg, min weight 1 kg");
            }
        } catch (ParserConfigurationException | IOException | SAXException e) {
            e.printStackTrace();
        }



public class ReadingFile { --- where reading file?
    public String filePath (String fileName) throws IOException {
        return  Objects.requireNonNull(getClass().getClassLoader().getResource(fileName)).getPath();
    }
}


this.distanc = scanSet("Enter distance"); ---> where is distancE


private Scanner scan;

    {   ----> initializing block
        scan = new Scanner(System.in);
    }

- Статический блок инициализатора будет вызываться при загрузке класса и не будет иметь доступа к переменным или методам экземпляра. Oн часто используется для создания статических переменных.
- Нестатический блок инициализатора, с другой стороны, создается только при построении объекта, будет иметь доступ к переменным и методам экземпляра и (согласно важной поправке, предложенной @EJP), будет вызываться в начале конструктора, после того, как супер конструктор был вызван (явно или неявно) и перед вызовом любого другого последующего кода конструктора. Я видел, как он использовался, когда класс имеет несколько конструкторов и нуждается в том же коде инициализации, который требуется для всех конструкторов. Как и в случае с конструкторами, вы должны избегать вызова не конечных методов в этом блоке. Позволяют проводить инициализацию объектов вне зависимости от того, какой конструктор был вызван или, например, вести журналирование:

class Foo {
	static List<Character> abc;
	static {
		abc = new LinkedList<Character>();
		for (char c = 'A'; c <= 'Z'; ++c) {
			abc.add( c );
		}
	}
}

Map<String, String> map = new HashMap<String, String>() {{
	put("паук",  "арахнид");
	put("птица", "архозавр");
	put("кит",   "зверь");
}};


======

public final Department addDepartment(final Department department) {
     Assert.notNull(department, "department cannot be null");
     assert department != null

Утверждения не должны использоваться для проверки аргументов в публичных методах по следующим причинам:

утверждения могут быть отключены, и проверки аргументов никогда не должны быть отключены, поскольку они 
являются частью контракта метода со своими вызывающими абонентами.

Ошибки утверждения не вызывают соответствующее исключение для недопустимых аргументов.
Пример:

    /**
     * @throws ArithmeticException if divisor is zero
     */ 
    public void int divide(int divisor) {
        if (divisor == 0) {
            throw new ArithmeticException("Cannot divide by zero");
        }
        ...
    }
Если вы использовали здесь утверждение, его можно было бы отключить, и он выбрал бы 
AssertionFailedException, который бесполезен и неинформирован.

--ea[:...|:] or enableassertions  (to enable assertion at a particular package and class level)
--da[:...|:] or disableassertions (to disable assertion on a package or class level)
--esa or enablesystemassertions  (for enabling system assertion)
--dsa or disablesystemassertions (for disabling system assertion)

https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html

======

department.setDescription(resultSet.getString(2 + 1)); -- ???

======

public final Department getDepartmentById(final int departmentId) {
        SqlParameterSource namedParameters = new MapSqlParameterSource("departmentId", departmentId);
        try {
            Department department = namedParameterJdbcTemplate.queryForObject(GET_DEPARTMENT_BY_ID_SQL,
                            namedParameters, new DepartmentRowMapper());
            return department;
        } catch (EmptyResultDataAccessException e) { -- ???
            return null;
        }
    }

======

@Override
    public Department addDepartment(Department department) {
        MapSqlParameterSource mapSqlParameterSource = new MapSqlParameterSource();
        mapSqlParameterSource.addValue("departmentName", department.getDepartmentName());
        mapSqlParameterSource.addValue("description", department.getDescription());
        namedParameterJdbcTemplate.update(ADD_DEPARTMENT_SQL, mapSqlParameterSource);
        Department added_department = getDepartmentByName(department.getDepartmentName()); -- ???
        return added_department;
    }

======

private class Queries { -- ???
    private static final String GET_DEPARTMENTS_SQL = "SELECT departmentId, departmentName, description FROM department";
    private static final String GET_DEPARTMENT_BY_ID_SQL =
            "SELECT departmentId, departmentName, description "
                    + "FROM department WHERE departmentId = :departmentId";
    private static final String ADD_DEPARTMENT_SQL = "INSERT INTO department (departmentName, description) "
                    + "VALUES (:departmentName, :description)";
    private static final String UPDATE_DEPARTMENT_SQL =
            "UPDATE department SET departmentName = :departmentName, "
                    + "description = :description "
                    + "WHERE departmentId = :departmentId";
    private static final String DELETE_DEPARTMENT_SQL = "DELETE FROM department WHERE departmentId = :departmentId";
}

======

public Department addDepartment(Department department) {
        Integer depId = (Integer) new SimpleJdbcInsert (jdbcTemplate).
                withTableName("department").usingGeneratedKeyColumns("departmentId").
                executeAndReturnKey(new BeanPropertySqlParameterSource(department));
        return getDepartmentById(depId); -- ???
}

======

@Test(expected = org.springframework.dao.EmptyResultDataAccessException.class)
public void deleteDepartment() {
    Department department = departmentDao.getDepartmentById(1);
    Assert.assertEquals("Distribution", department.getDepartmentName());
    departmentDao.deleteDepartmentById(1);
    departmentDao.getDepartmentById(1);
}

======

    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Test
    public void deleteDepartmentByID() {
        departmentDao.deleteDepartmentByID(2);
        exception.expect(EmptyResultDataAccessException.class);
        departmentDao.getDepartmentByID(2);
    }
    
    http://blog.qatools.ru/junit/junit-rules-tutorial

======

    @Override
    public Department addDepartment(Department department) {
        if (getDepartmentByName(department.getDepartmentName()) != null)
            return null;
        else {
            SqlParameterSource namedParametres = new MapSqlParameterSource("department_name", department.getDepartmentName());
            ((MapSqlParameterSource) namedParametres).addValue("description", department.getDescription());
            namedParameterJdbcTemplate.execute(add_department_sql, namedParametres, new PreparedStatementcallback());
            return department;
        }
    }
    
    
    @Override
    public boolean removeDepartmentById(int departmentid) {
        SqlParameterSource namedParametres = new MapSqlParameterSource("department_id", departmentid);
        Object o = namedParameterJdbcTemplate.execute(remove_department_by_id_sql, namedParametres, new PreparedStatementcallback());
        if ((Integer) o == 1)
            return true;
        else
            return false;
    }    

======


